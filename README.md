
# **Документация по системе мониторинга и управления инцидентами**

## **1. Введение**

### **1.1. Назначение**
Система мониторинга и управления инцидентами предназначена для сбора, анализа и обработки данных о состоянии микросервисной инфраструктуры компании. Основные задачи системы:
- Мониторинг метрик, логов, трейсов и событий.
- Обнаружение аномалий и создание инцидентов.
- Автоматизация устранения сбоев.
- Управление инцидентами и эскалация в ответственные команды.
- Интеграция с DevOps-инструментами.
- Визуализация данных и аналитика.

### **1.2. Целевая аудитория**
Система предназначена для:
- DevOps-инженеров.
- SRE-команд.
- Системных администраторов.
- Руководителей технических отделов.

---

## **2. Архитектура**

### **2.1. Общая схема компонентов**

```mermaid
graph TD;
  A[Data Collector] -->|Kafka (метрики, логи)| B[Data Processor]
  B -->|InfluxDB| C[Хранение метрик]
  B -->|Elasticsearch| D[Хранение логов]
  B -->|Kafka (события)| E[Event Generator]
  E -->|Redis| F[Кеширование активных инцидентов]
  E -->|Incident Manager API| G[Incident Manager]
  G -->|PostgreSQL| H[Хранение инцидентов]
  G -->|RabbitMQ| I[Notifier Service]
  I -->|Slack, Telegram, Email| J[Уведомления]
  G -->|Remediation Engine API| K[Remediation Engine]
  K -->|MongoDB| L[Скрипты устранения]
  G -->|Grafana API| M[Dashboard Service]
```

### **2.2. Основные компоненты системы**
1. **Data Collector** – собирает данные из сервисов и отправляет в Kafka.
2. **Data Processor** – анализирует данные, выявляет аномалии.
3. **Event Generator** – создаёт инциденты при обнаружении проблем.
4. **Incident Manager** – управляет инцидентами и эскалацией.
5. **Remediation Engine** – автоматически исправляет сбои.
6. **Notifier Service** – отправляет уведомления пользователям.
7. **Dashboard Service** – визуализирует метрики и инциденты.

---

## **3. API и интеграции**

### **3.1. Data Collector API**

#### **POST /metrics**
Отправка метрик в систему.

**Пример запроса:**
```json
{
  "service_id": "user-service",
  "timestamp": "2025-02-16T12:00:00Z",
  "metrics": {
    "latency": 120,
    "error_rate": 0.02
  }
}
```

**Пример ответа:**
```json
{
  "status": "received"
}
```

### **3.2. Incident Manager API**

#### **GET /incidents**
Получение списка активных инцидентов.

**Пример ответа:**
```json
[
  {
    "id": "12345",
    "service": "user-service",
    "severity": "high",
    "status": "open",
    "timestamp": "2025-02-16T12:05:00Z"
  }
]
```

### **3.3. Notifier Service API**

#### **POST /notify**
Отправка уведомления в указанный канал.

**Пример запроса:**
```json
{
  "incident_id": "12345",
  "channel": "slack",
  "message": "Критический инцидент в user-service!"
}
```

---

## **4. Базы данных и хранение данных**

### **4.1. PostgreSQL (Incidents DB)**
Хранит информацию об инцидентах.

**Таблица `incidents`**
| Поле       | Тип        | Описание                           |
|------------|-----------|-----------------------------------|
| id         | UUID      | Уникальный идентификатор         |
| service    | TEXT      | Название сервиса                 |
| severity   | TEXT      | Уровень критичности (high, low)  |
| status     | TEXT      | Статус инцидента                 |
| created_at | TIMESTAMP | Дата создания                    |

### **4.2. InfluxDB (Metrics DB)**
Используется для хранения временных рядов метрик.

**Пример записи:**
```
latency,service=user-service value=120 1708050000
error_rate,service=user-service value=0.02 1708050000
```

### **4.3. Elasticsearch (Logs DB)**
Хранит логи всех сервисов.

**Пример запроса на поиск логов:**
```json
{
  "query": {
    "match": {
      "message": "ошибка"
    }
  }
}
```

---

## **5. Автоматизация устранения инцидентов**

### **5.1. Запуск скриптов Remediation Engine**

#### **POST /run-script**
Запуск автоматического исправления.

**Пример запроса:**
```json
{
  "incident_id": "12345",
  "script_name": "restart_pod",
  "parameters": {
    "namespace": "user-service",
    "pod_name": "user-service-123"
  }
}
```

**Пример ответа:**
```json
{
  "status": "executed",
  "logs": "Pod user-service-123 restarted successfully"
}
```

---

## **6. Настройка уведомлений**

### **6.1. Подключение Telegram**
1. Создать бота через `@BotFather`.
2. Получить токен и добавить его в конфигурацию:
   ```
   TELEGRAM_BOT_TOKEN=123456:ABC-DEF1234ghIkl
   ```
3. Подписаться на уведомления `/subscribe`.

### **6.2. Интеграция с Slack**
1. Создать приложение в Slack API.
2. Добавить webhook-URL в конфиг:
   ```
   SLACK_WEBHOOK_URL=https://hooks.slack.com/services/XXX
   ```
3. Настроить канал уведомлений через `/settings notify`.

---

## **7. Безопасность и доступ**

### **7.1. Аутентификация и авторизация**
- Используется **OAuth2 + JWT** для API.
- Доступ к API возможен только с **валидным токеном**.

### **7.2. Роли пользователей**
| Роль        | Доступ                                    |
|------------|------------------------------------------|
| User       | Просмотр инцидентов                      |
| Engineer   | Управление инцидентами                   |
| Admin      | Полный доступ, редактирование настроек  |

---

## **8. Масштабируемость и отказоустойчивость**

### **8.1. Горизонтальное масштабирование**
- **Kafka** распределяет нагрузку между партициями.
- **Elasticsearch** поддерживает шардирование логов.
- **Kubernetes** автоматически балансирует поды.

### **8.2. Обеспечение отказоустойчивости**
- **Резервные реплики баз данных (PostgreSQL, ClickHouse).**
- **Мониторинг состояния сервисов через Prometheus.**
- **Автоматическое переключение при отказе (Failover).**

---

## **9. Развёртывание в облаке**

### **9.1. Подготовка инфраструктуры**
1. Развернуть Kubernetes-кластер.
2. Настроить Kafka, Redis, PostgreSQL.
3. Установить Prometheus и Grafana.

### **9.2. Развёртывание через Helm**
```sh
helm install alertify ./charts/alertify
```

---

## **10. Контрольные команды (CLI)**

### **10.1. Проверка статуса сервисов**
```sh
kubectl get pods -n monitoring
```

### **10.2. Запуск тестового инцидента**
```sh
curl -X POST http://incident-manager/incidents/test
```

---

**Документация находится в разработке.
